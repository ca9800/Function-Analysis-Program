"""
NOTES:
- to do exponents do ** not ^
- def of a derivitive = f' = (f(x+h) - f(x))/h as h approaches 0
- print (x, ",", eval(f)) 

"""
from ggame import App, Color, LineStyle, Sprite, RectangleAsset, CircleAsset, EllipseAsset, PolygonAsset
from math import sin, cos, tan, radians

#inputs
f = input("enter a function equal to f(x) in terms of x: ")         #user inputs the funciton they want
#a = int(input("what is the lower limit of your interval?: "))      #user inputs the domain of the function 
#b = int(input("what is the upper limit of your interval?: "))      #user inputs the domain of the function
a = -5
b = 5

rangee = list(range(a,b+1))


fx = range(a, b+1)
(list(fx))   #list of x-values
h = 0.000001                 #defines delta x or h


########_finds f'
f1 = []                         # creates f1 which is a list that will contain y values for the function
for x in range(a,b+1):
    hk = eval(f)
    f1.append(hk)           #calcuates f(x) and puts in f1



fprime = []     #creates a list that will contain fprimes
crit = [a]
for x in range (a,b+1):         
   x = h+x                      #redefines x as x + h to find f(x+h)
   fh= eval(f)                  #calculates f(x+h)
   x = float(x-h+.1)-a            #redefines x so that it points to the coresponding f(x) value in f1
   p = round(((fh-f1[x])/h), 4) #rounds fprime
   fprime.append(p)             # calculates the derivitive using the definition of a derivitive and puts in fprime
   

for ppp in fprime:
    pos = fprime.index(ppp)         # position of ppp in fprime
    if ppp>= -0.05 and ppp<=0.05:
        x = rangee[pos]
        crit.append(x)
crit.append(b)          #adds b to critical values
print("critical x-values",crit)
for cc in crit:
    print("(", cc , "," , eval(f), ")")




#prints function outputs
print (" ") 
print ("f(x) in range", a, "to", b, "equals: ") 
print (f1)

print (" ") 
print ("f'(x) in range", a, "to", b, "equals: ") 
print (fprime)




##############_finding f"

f2 = []                         # f(x+2h)-f(x+h)/h or f'(x+h)
for x in range (a,b+1):
    x = x + 2*h
    fj = eval(f)
    f2.append(fj)


f5 = []                         # f(x+2h)-f(x+h)/h or f'(x+h)
for x in range (a,b+1):   
    x = x+h
    fp = eval(f)
    f5.append(fp)


f6 = []
for x in range (a,b+1):
    q = (f2[x]-f5[x])/(h)
    f6.append(q)


f3 = []                         # f(x+h)-f(x)/h or f'(x)
for x in range(a, b+1):
    x = x + h
    fi = eval(f)
    f3.append(fi)
    
f4 = []                         # f(x+h)-f(x)/h or f'(x)
for x in range(a, b+1):  
    ae = (f3[x]-f1[x])/h
    f4.append(ae)
    

fdouble = []                    # actual f' 

for x in range(a-1, b):
    s = round((f6[x]-f4[x])/h, 3)
    fdouble.append(s)




print (" ")  
print ("f''(x) in range", a, "to", b, "equals: ") 
print (fdouble)


print ("h ") 

#print("absolute min: ", (x, min(f1)))
#print("absolute max: ", (x, max(f1)))

###############################################
### Creates function, first and second derivatives

tstep = .1
xyList0 = []
t = a
#create a list of xy values, each x will be tstep apart
#f(x)
while t<b+1:
    x=t
    xyList0.append((t, eval(f)))
    t += tstep


xyList1 = []
t = a
#create a list of xy values, each x will be tstep apart
#f'(x)
count = 0
while t<b-tstep:
    xyList1.append((t, (xyList0[count+1][1]-xyList0[count][1])/tstep ))
    t += tstep
    count += 1

xyList2 = []
t = a
count = 0
#create a list of xy values, each x will be tstep apart
#f''(x)
while t<b-2*tstep:
    xyList2.append((round(t, 7), round((xyList1[count+1][1]-xyList1[count][1])/tstep, 7) ))
    t += tstep
    count +=1
    
    

################################################

# Finds the points of inflection by finding the ones that are close to zero
flex = [] # list that will contains points
t = a # gives starting point for x
count = 0 # records position in current list and allows for access to second deriv
currentN = 0 # current lowest point
currentL = 1 # last lowest point
diff = 0

while t<b-3*tstep:
    currentL = currentN # saves the current lowest value
    diff = abs(xyList2[count][1]) - abs(xyList2[count-1][1]) # calculates wether or not approaching X axis
    if abs(xyList2[count+1][1]) < abs(xyList2[count][1]): # if the next is less than the current
        currentN = (xyList2[count+1][0], xyList2[count+1][1]) # set the current as the lowest

    if currentN == currentL and diff<0:# if the saved and the new lowest are the same, and approaching Xaxis
        flex.append((count-1, currentN[0], currentN[1])) # append value to inflection points (flex)
    t += tstep #goes through the x values in the given range a to be in tstep steps
    count +=1 #reffers to index placement
    
# Makes useful critical values
crit = [(0, xyList0[0][0], xyList0[0][1])] #places start point as cirtical value
for x in flex: #
    crit.append(x)
crit.append((count+2, xyList0[count+2][0], xyList0[count+2][1]))

# find concave up/down
conch = []
t=0
while t<len(crit)-1:
    if xyList2[crit[t][0]+5][1] < 0:
        conch.append(str("From "+str(crit[t][1])+" to "+str(crit[t+1][1])+": concave down"))
    elif xyList2[crit[t][0]+5][1] > 0:
        conch.append(str("From "+str(crit[t][1])+" to "+str(crit[t+1][1])+": concave up"))
    t+=1
print(conch)
    
#print(xyList0)
print()
#print(xyList1)
print()
#print(xyList2)
print()

#print("points of infelction for function f(x) in range", a, "to", b, "equal", flex)

